name: Deploy to Staging EC2

on:
  push:
    branches: [ staging ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:

jobs:
  lint:
    name: Lint Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: 'frontend/package-lock.json'
        
    - name: Lint Frontend
      run: |
        cd frontend
        npm ci
        npm run lint
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Lint Backend (Go)
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        working-directory: ./backend
        args: --timeout=5m

  deploy:
    name: Deploy to Staging EC2
    runs-on: ubuntu-latest
    needs: lint
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-southeast-1
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    - name: Generate docker-compose.staging.yml
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Get AWS Account ID from registry URL
        AWS_ACCOUNT_ID=$(echo $ECR_REGISTRY | cut -d. -f1)
        
        cat > docker-compose.staging.yml << EOL
        # Docker Compose file untuk staging (otomatis generated by GitHub Actions)
        name: getstok-fleet-monitoring-staging

        services:
          # Frontend service
          frontend:
            image: ${ECR_REGISTRY}/getstok-frontend:latest
            container_name: getstok-frontend-staging
            restart: unless-stopped
            ports:
              - "3000:3000"
            env_file:
              - ./frontend/.env
            networks:
              - getstok-network-staging
            depends_on:
              - backend
              - notification-service
            environment:
              - NODE_ENV=production

          # Backend service dengan PostgreSQL
          postgres:
            image: postgres:16-alpine
            container_name: getstok_postgres_staging
            ports:
              - "5433:5432"
            env_file:
              - ./backend/.env.db
            volumes:
              - postgres_data_staging:/var/lib/postgresql/data
            restart: always
            networks:
              - getstok-network-staging
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U ybandung"]
              interval: 5s
              timeout: 5s
              retries: 5

          backend:
            image: ${ECR_REGISTRY}/getstok-backend:latest
            container_name: getstok_api_staging
            restart: unless-stopped
            ports:
              - "8080:8080"
            env_file:
              - ./backend/.env
            environment:
              - MQTT_BROKER_URL=tcp://getstok-mqtt-staging:1883
              - APP_ENV=staging
            depends_on:
              postgres:
                condition: service_healthy
              mqtt-broker:
                condition: service_started
            networks:
              - getstok-network-staging

          # Notification service
          notification-service:
            image: ${ECR_REGISTRY}/getstok-notification:latest
            container_name: getstok-notification-staging
            restart: unless-stopped
            ports:
              - "8081:8081"
            env_file:
              - ./notification_service/.env
            environment:
              - DB_HOST=postgres
              - NODE_ENV=production
              - APP_ENV=staging
            depends_on:
              postgres:
                condition: service_healthy
            networks:
              - getstok-network-staging

          # MQTT Broker service
          mqtt-broker:
            image: ${ECR_REGISTRY}/getstok-mqtt:latest
            container_name: getstok-mqtt-staging
            restart: unless-stopped
            ports:
              - "1883:1883"  # MQTT default port
              - "9001:9001"  # WebSockets port
            networks:
              - getstok-network-staging

        networks:
          getstok-network-staging:
            driver: bridge

        volumes:
          postgres_data_staging:
            driver: local
        EOL
        
        # Create ECR login script
        cat > ecr-login.sh << EOL
        #!/bin/bash
        aws ecr get-login-password --region ap-southeast-1 | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.ap-southeast-1.amazonaws.com
        EOL
        chmod +x ecr-login.sh
        
    - name: Copy docker-compose.staging.yml and ECR login script to EC2
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/ec2_staging.pem
        chmod 600 ~/.ssh/ec2_staging.pem
        
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_staging.pem docker-compose.staging.yml ec2-user@${{ secrets.STAGING_EC2_HOST }}:~/GetstokFleetMonitoring-staging/
        scp -o StrictHostKeyChecking=no -i ~/.ssh/ec2_staging.pem ecr-login.sh ec2-user@${{ secrets.STAGING_EC2_HOST }}:~/GetstokFleetMonitoring-staging/
        
    - name: Deploy to Staging EC2
      run: |
        ssh \
          -o ServerAliveInterval=60 \
          -o ServerAliveCountMax=60 \
          -o StrictHostKeyChecking=no \
          -i ~/.ssh/ec2_staging.pem \
          ec2-user@${{ secrets.STAGING_EC2_HOST }} '
          # Log directory
          mkdir -p ~/deploy-logs
          
          # Log file
          LOG_FILE=~/deploy-logs/deploy-staging-$(date +%Y-%m-%d-%H-%M-%S).log
          
          # Start logging
          {
            echo "=== Staging Deployment started at $(date) ==="
            
            # Check disk space before deployment
            echo "Current disk usage:"
            df -h /
            
            # Install Docker and Docker Compose if not available
            if ! command -v docker &> /dev/null; then
              echo "Docker not found. Installing Docker..."
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -a -G docker ec2-user
            fi
            
            if ! command -v docker-compose &> /dev/null; then
              echo "Docker Compose not found. Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Install AWS CLI if not available
            if ! command -v aws &> /dev/null; then
              echo "AWS CLI not found. Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            
            # Configure AWS
            if [ ! -f ~/.aws/credentials ] || [ ! -f ~/.aws/config ]; then
              echo "Configuring AWS CLI..."
              mkdir -p ~/.aws
              
              # Create credentials file if it doesn't exist
              if [ ! -f ~/.aws/credentials ]; then
                echo "[default]" > ~/.aws/credentials
                echo "aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" >> ~/.aws/credentials
                echo "aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> ~/.aws/credentials
              fi
              
              # Create config file if it doesn't exist
              if [ ! -f ~/.aws/config ]; then
                echo "[default]" > ~/.aws/config
                echo "region=ap-southeast-1" >> ~/.aws/config
                echo "output=json" >> ~/.aws/config
              fi
            fi
            
            # Update repository with git pull
            echo "Updating repository with git pull..."
            if [ -d ~/GetstokFleetMonitoring-staging ]; then
              cd ~/GetstokFleetMonitoring-staging
              # Check for local changes and reset if needed
              git status --porcelain | grep -q . && git reset --hard
              git checkout staging
              git pull origin staging
            else
              # If directory does not exist, create and clone
              echo "Directory not found, creating and cloning repository..."
              mkdir -p ~/GetstokFleetMonitoring-staging
              cd ~/GetstokFleetMonitoring-staging
              git clone -b staging https://github.com/hafidzyami/GetstokFleetMonitoring.git .
            fi
            
            # Ensure all .env files exist
            if [ -f backend/.env.example ] && [ ! -f backend/.env ]; then
              echo "Creating backend/.env from backend/.env.example"
              cp backend/.env.example backend/.env
              
              # Change configuration for staging if needed
              sed -i "s/NODE_ENV=production/NODE_ENV=production/" backend/.env
              sed -i "s/APP_ENV=production/APP_ENV=staging/" backend/.env
            fi
            
            if [ -f backend/.env.db.example ] && [ ! -f backend/.env.db ]; then
              echo "Creating backend/.env.db from backend/.env.db.example"
              cp backend/.env.db.example backend/.env.db
            fi
            
            if [ -f notification_service/.env.example ] && [ ! -f notification_service/.env ]; then
              echo "Creating notification_service/.env from notification_service/.env.example"
              cp notification_service/.env.example notification_service/.env
            fi
            
            if [ -f frontend/.env.example ] && [ ! -f frontend/.env ]; then
              echo "Creating frontend/.env from frontend/.env.example"
              cp frontend/.env.example frontend/.env
              
              # Change API endpoint for staging if needed
              sed -i "s/NEXT_PUBLIC_API_URL=.*/NEXT_PUBLIC_API_URL=https:\/\/staging-api.getstokfms.com/" frontend/.env
            fi
            
            # Make sure required directories for mqtt broker exist
            echo "Checking and creating MQTT broker directories if needed..."
            mkdir -p mqtt_broker/mqtt/data mqtt_broker/mqtt/log
            chmod -R 777 mqtt_broker/mqtt/data mqtt_broker/mqtt/log
            
            # Ensure Docker is running
            if ! systemctl is-active --quiet docker; then
              echo "Starting Docker service..."
              sudo systemctl start docker
            fi
            
            # Login to ECR
            echo "Logging in to Amazon ECR..."
            bash ./ecr-login.sh
            
            # Verify login worked
            echo "Verifying ECR login..."
            if ! docker info | grep -q "Username: AWS"; then
              echo "ECR login failed. Trying alternative method..."
              aws ecr get-login-password --region ap-southeast-1 | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.ap-southeast-1.amazonaws.com
            fi
            
            # Stop existing containers
            echo "Stopping existing containers..."
            if [ -f docker-compose.staging.yml ]; then
              docker-compose -f docker-compose.staging.yml down
            fi
            
            # Selective cleanup
            echo "Performing selective Docker cleanup..."
            docker image prune -f
            
            # Pull and start with new images
            echo "Pulling and starting containers using staging configuration..."
            
            # Check if the images already exist locally
            for image in "getstok-frontend" "getstok-backend" "getstok-notification" "getstok-mqtt"; do
              if ! docker image inspect $(aws sts get-caller-identity --query Account --output text).dkr.ecr.ap-southeast-1.amazonaws.com/$image:latest &>/dev/null; then
                echo "Pulling $image image..."
                docker pull $(aws sts get-caller-identity --query Account --output text).dkr.ecr.ap-southeast-1.amazonaws.com/$image:latest || echo "Failed to pull $image, will retry with docker-compose"
              fi
            done
            
            # Try with docker-compose pull
            docker-compose -f docker-compose.staging.yml pull
            
            # Start containers
            docker-compose -f docker-compose.staging.yml up -d
            
            # Display status
            echo "Container status:"
            docker-compose -f docker-compose.staging.yml ps
            
            # Clean up unused Docker resources
            echo "Cleaning up unused Docker resources..."
            docker image prune -f
            
            # Cleanup old logs (keep only the most recent 10)
            echo "Cleaning up old deployment logs..."
            cd ~/deploy-logs
            ls -t | tail -n +11 | xargs -r rm
            
            # Check disk space after deployment
            echo "Disk usage after deployment:"
            df -h /
            
            echo "=== Staging Deployment completed at $(date) ==="
          } 2>&1 | tee -a "$LOG_FILE"
          
          # Display result
          echo "Staging Deployment completed. Log saved to $LOG_FILE"
        '